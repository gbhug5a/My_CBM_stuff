This is about the Commodore Plus/4 computer's Kernal rom code which services IRQ interrupts from the 6551 (aka 8551) ACIA.  The code contains one outright error, and has three additional shortcomings that reduce performance.  Provided here is replacement code located in the cassette buffer (but can be located anywhere below $8000) which is accessed by redirecting the IRQ ram vector at $0314/0315.  Here are the four issues:

1.  The coding error occurs where a new received byte is read from the ACIA.  Here's the Kernal code:

        LDA $FD00
        BEQ EAC2
        STA $07D5
        .
        .
        [do various testing for xon/xoff software flow control]
        .
        .
EAC2:   LDA  $07D5
        [store in the input queue]

The branch is needed to prevent a null byte from triggering false xon and xoff states if flow control is NOT enabled.  However, the null should first be saved in $07D5, which the rom does not do.  The result is that no null byte can ever make its way into the input queue, and every null byte received will result in duplication of the most recent non-null byte received.  That makes file transfers virtually impossible. The correct code would have been:

        LDA $FD00
        STA $07D5
        BEQ EAC2


2.  If both the transmit data register and the transmit shift register are empty, and if a new outgoing byte is written to the data register, that byte is immediately transferred to the shift register, and an interrupt is immediately generated by the 6551 indicating the data register is empty again.  If an output data queue is implemented in rom, that interrupt could be used to again load the data register with the next byte, so transmission can be continuous.  However, the Plus/4 has only a single-byte output queue, so when that new interrupt is serviced immediately following the current one, there is never another byte to load in.  As a result, each byte transmitted will result in an extra interrupt which follows immediately on the current interrupt, and which accomplishes nothing and only wastes time.  With transmit interrupts enabled, transmitting 10 bytes will result in 20 interrupts serviced, only 10 of which do anything useful.  Particularly at high baud rates, these extra interrupts will degrade performance.


3.  It has been reported that in some 6551 chips bit 7 of the Status register is not always set as it should be when the 6551 triggers an interrupt.  For such chips, code which checks that bit, and bypasses ACIA servicing if it is not set, may miss incoming bytes, and performance will be flaky.  It is not known whether the 8551 found in the Plus/4 suffers from this problem, but the Kernal rom does use the bit 7 test.


4.  Typically, transmit interrupts, which occur at the byte rate, would be enabled when there is something to send, and then disabled when there is nothing more to send.  The Plus/4 rom leaves transmit interrupts enabled whenever the 6551 is in use, even if no communications are taking place.  At high baud rates, this results in enough IRQ servicings to degrade performance.  At 19200 baud, there will be 1920 interrupts serviced per second whether there is any outgoing traffic or not.




The replacement IRQ servicing code presented here addresses these issues within the framework of the existing Kernal and BASIC roms.  While it would be good to have, for example, a real transmit queue, that would require modifying the memory map and the other input and output routines which deal with the ACIA, and that is considered to be unrealistic.  So the replacement code assumes nothing else is changed.  The issues described above are addressed as follows:


1.  The receive routine itself is unchanged, but before entering it a null is stored in $07D5.  Then if a null is retrieved from the 6551, a null will be retrieved from $07D5 and stored in the input queue, as it should be.  If a non-null byte is received, it will be written to $07D5.  In either case, the byte retrieved from $07D5 will be the byte that was actually received from the ACIA.


2.  After a byte is written to the transmit data register, after a short delay the status register is read again.  That has the effect of clearing the IRQ line and effectively aborting the additional interrupt.  However, since there could have been a new byte received since entering the current servicing routine, if the receive flag bit is set on either read of the status register, then the receive routine will be executed.  The first read of the status register is stored in $07D4, and that value is ORed with the second status register value.  If the receive flag bit was set in either read, the receive routine will run and the new byte will be fetched.


3.  Rather than depend on bit 7 to be set on an ACIA interrupt, we test the receive and transmit flag bits individually.  This adds a bit more execution time to each interrupt because those tests will be done even if the interrupt is from another source, such as the raster interrupt.  But it's only a few clock cycles, and reportedly solves the bit 7 problem (the receive and transmit flags apparently are not flaky like bit 7).


4.  The new IRQ code makes sure transmit interrupts are enabled each time a byte is transmitted.  It also sets up a down counter, and on each subsequent interrupt, if there is nothing to send, it counts down.  If it reaches zero, it disables transmit interrupts.  From that point, the code must wait for a raster interrupt to allow the first new outgoing byte to be sent.  Since raster interrupts only occur at 60 Hz or less, they can't be depended upon to transmit every byte.  But leaving transmit interrupts enabled for three byte times after the first byte should allow for truly high speed transmission since the counter will be re-initialzed on each outgoing byte, so transmit interrupts will remain enabled.  This method is made possible by the fix for issue 3 since since any interrupt source, not just the ACIA, will cause the transmit queue to be checked for a new outgoing byte.  The ACIA device should be OPENed with transmit interrupts disabled in the Command register.  The new IRQ code will manage transmit interrupts thereafter.


The BASIC loader program reads the new code from the DATA statements and pokes it into the cassette buffer at $0333 (819).  Then SYS 819 hijacks the IRQ ram vector at $0314/0315 so it points to the new code.  The loader need not be kept in memory after that.  The code can tell where it has been placed, and there are no internal references, so it's not necessary to re-assemble the code before placing it somewhere else.
