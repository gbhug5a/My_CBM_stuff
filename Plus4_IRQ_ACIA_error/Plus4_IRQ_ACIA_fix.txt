10 rem this code bypasses the "beq" bug
12 rem in the +4's irq acia received-
14 rem byte routine, and eliminates the
16 rem xon/xoff software flow control
18 rem code in both xmit and receive.
20 rem the irq service routine vector
22 rem ($0314) normally points to $ce0e.
24 rem this code duplicates that code up
26 rem to the acia, fixes that, then
28 rem jumps back into rom.  the code is
30 rem poked into the cassette buffer at
32 rem $0333, but can be placed anywhere
34 rem visible in ram when kernel and
36 rem basic roms are banked in.  sys
38 rem to the first byte to take over
40 rem $0314. no need to re-assemble for
42 rem a different location. the code
44 rem detects where it has been placed.
46 rem sys (first byte + 26) to restore
48 rem the the $0314 vector to $ce0e.
100 cb = 819
110 for i = 0 to 119
120 read a
130 poke cb+i,a
140 next
150 sys cb
160 v= (peek(789)*256) + peek(788)
170 print "irq ram vector now";v
180 data 120,32,85,252,186,202,189,0
190 data 1,24,105,36,141,20,3,232
200 data 189,0,1,105,0,141,21,3
210 data 88,96,120,169,14,141,20,3
220 data 169,206,141,21,3,88,96,173
230 data 9,255,41,2,240,3,32,96
240 data 206,44,216,7,16,63,173,1
250 data 253,141,212,7,16,55,173,212
260 data 7,41,8,240,24,173,212,7
270 data 41,247,141,212,7,173,0,253
280 data 141,213,7,173,211,7,201,63
290 data 240,3,32,220,234,173,212,7
300 data 41,16,240,17,173,16,253,41
310 data 2,240,10,162,0,44,206,7
320 data 16,3,32,131,234,76,43,206
